---
globs: main.py,*bot*.py
---

# Telegram Bot Development Patterns

## Core Bot Architecture

This rule applies to Telegram bot development, specifically the patterns used in [main.py](mdc:main.py) and related bot functionality.

## Command Handler Patterns

### 1. Command Registration

Always register commands in a centralized manner:

```python
# Good: Centralized command registration
def create_application(self) -> Application:
    application = Application.builder().token(self.token).build()

    # Add handlers in logical order
    application.add_handler(CommandHandler("start", self.start_command))
    application.add_handler(CommandHandler("help", self.help_command))
    application.add_handler(CommandHandler("reset", self.reset_command))
    application.add_handler(CommandHandler("clear", self.reset_command))  # Alias
    application.add_handler(CommandHandler("stats", self.stats_command))
    application.add_handler(CommandHandler("model", self.model_command))

    return application
```

### 2. Command Handler Structure

Follow consistent command handler patterns:

```python
# Good: Standard command handler signature and structure
async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /start command."""
    user = update.effective_user

    # Ensure user exists in database
    await self.db.get_or_create_user(
        user.id, user.username, user.first_name, user.last_name
    )

    # Send formatted response
    await update.message.reply_text(welcome_message, parse_mode=ParseMode.HTML)
```

### 3. Error Handling in Commands

Always include error handling:

```python
# Good: Comprehensive error handling
async def model_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        available_models = await self.cerebras_chat.get_available_models()
        # ... command logic
    except Exception as e:
        logger.error(f"Error in model_command: {e}")
        await update.message.reply_text(
            "üö´ <b>Error</b>\n\nSorry, I couldn't fetch the available models.",
            parse_mode=ParseMode.HTML
        )
```

## Message Processing Patterns

### 1. Rate Limiting Implementation

Always implement rate limiting for user messages:

```python
# Good: Rate limiting check before processing
async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id

    # Check rate limiting first
    if not await self.db.check_rate_limit(
        user_id, self.rate_limit_messages, self.rate_limit_window
    ):
        await update.message.reply_text(
            f"‚è≥ <b>Rate limit exceeded</b>\n\n"
            f"Please wait before sending another message.",
            parse_mode=ParseMode.HTML
        )
        return
```

### 2. User Context Building

Build comprehensive user context for AI processing:

```python
# Good: Comprehensive user context
user_context = {
    # User information from Telegram
    "user_id": user.id,
    "username": user.username,
    "first_name": user.first_name,
    "language_code": user.language_code,
    "is_premium": getattr(user, "is_premium", None),

    # Chat context
    "chat_id": update.effective_chat.id,
    "chat_type": update.effective_chat.type,
    "message_date": update.message.date.isoformat() if update.message.date else None,

    # Conversation statistics
    "total_messages": len(conversation_history),
    "is_new_user": len(conversation_history) == 0,
    "reaction_count": user_stats.get("reaction_count", 0) if user_stats else 0
}
```

### 3. Typing Indicators

Implement typing indicators for better UX:

```python
# Good: Async typing indicators
async def start_typing_indicator(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id

    # Cancel any existing typing task
    if user_id in self.typing_tasks:
        self.typing_tasks[user_id].cancel()

    async def typing_loop():
        try:
            while True:
                await context.bot.send_chat_action(
                    chat_id=update.effective_chat.id,
                    action=ChatAction.TYPING
                )
                await asyncio.sleep(4)  # Telegram typing indicator lasts ~5 seconds
        except asyncio.CancelledError:
            pass

    self.typing_tasks[user_id] = asyncio.create_task(typing_loop())
```

## HTML Response Formatting

### 1. Telegram HTML Requirements

**CRITICAL**: Telegram has strict HTML parsing requirements. Follow these exactly:

```python
# ONLY use these 7 allowed HTML tags:
# <b>text</b>, <i>text</i>, <u>text</u>, <s>text</s>
# <code>text</code>, <pre>text</pre>, <a href="url">text</a>

# Good: Proper HTML formatting
welcome_message = """
ü§ñ <b>Welcome to the Cerebras AI Bot!</b>

I'm powered by <i>Cerebras AI</i> and I'm here to help you!

<b>Available Commands:</b>
‚Ä¢ <code>/start</code> - Show this welcome message
‚Ä¢ <code>/help</code> - Get detailed help information
‚Ä¢ <code>/reset</code> or <code>/clear</code> - Clear your conversation history

<b>Features:</b>
‚ú® <u>Intelligent conversations</u> with context
üíæ <u>Persistent conversation memory</u>
‚ö° <u>Fast responses</u> powered by Cerebras
"""
```

### 2. Character Escaping

Always escape special HTML characters:

```python
# Good: HTML character escaping
stats_message = f"""
<b>User Info:</b>
‚Ä¢ Username: <code>@{html.escape(str(stats.get('username', 'N/A')))}</code>
‚Ä¢ Name: <i>{html.escape(str(stats.get('first_name', 'N/A')))}</i>
"""
```

### 3. Response Length Limits

Telegram has a 4096 character limit:

```python
# Good: Length checking and truncation
def _ensure_telegram_length_limit(self, message: str) -> str:
    """Ensure message fits Telegram's 4096 character limit."""
    if len(message) > 4000:  # Leave some buffer
        return message[:3900] + "\n\n<i>... (message truncated)</i>"
    return message
```

## Inline Keyboard Patterns

### 1. Dynamic Keyboard Generation

Create keyboards dynamically based on data:

```python
# Good: Dynamic inline keyboard for model selection
keyboard = []
for i in range(0, len(available_models), models_per_row):
    row = []
    for j in range(models_per_row):
        if i + j < len(available_models):
            model = available_models[i + j]
            # Add indicators for current model and features
            if model == current_model:
                display_text = f"‚úÖ {model}"
            else:
                display_text = f"üß†{model}" if self._model_supports_reasoning(model) else model

            row.append(InlineKeyboardButton(
                display_text,
                callback_data=f"model_select:{model}"
            ))
    keyboard.append(row)

reply_markup = InlineKeyboardMarkup(keyboard)
```

### 2. Callback Query Handling

Handle callback queries with proper error handling:

```python
# Good: Callback query handling
async def model_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()  # Always answer callback queries

    try:
        # Parse callback data safely
        if not query.data.startswith("model_select:"):
            return

        selected_model = query.data.split(":", 1)[1]

        # Update database
        await self.db.set_user_preferred_model(user_id, selected_model)

        # Update message
        await query.edit_message_text(success_message, parse_mode=ParseMode.HTML)

    except Exception as e:
        logger.error(f"Error in callback: {e}")
        await query.edit_message_text(
            "üö´ <b>Error</b>\n\nSorry, there was an error processing your selection.",
            parse_mode=ParseMode.HTML
        )
```

## User Experience Patterns

### 1. Message Acknowledgment

Always acknowledge user messages:

```python
# Good: Message acknowledgment with reactions
try:
    await update.message.set_reaction("üëç")
    await self.db.add_message_reaction(
        user_id, update.message.message_id, "üëç"
    )
except Exception as e:
    logger.warning(f"Could not set reaction: {e}")
    # Continue processing - reaction is not critical
```

### 2. Progressive Disclosure

Show information progressively based on user needs:

```python
# Good: Basic help vs detailed help
async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
    help_message = f"""
üÜò <b>Help &amp; Commands</b>

<b>Basic Commands:</b>
‚Ä¢ <code>/start</code> - Welcome message
‚Ä¢ <code>/help</code> - This help message
‚Ä¢ <code>/stats</code> - View usage statistics

<b>Rate Limits:</b>
‚Ä¢ Maximum <i>{self.rate_limit_messages}</i> messages per <i>{self.rate_limit_window}</i> seconds
"""
```

### 3. Error Recovery

Provide clear error messages and recovery options:

```python
# Good: Clear error messages with recovery suggestions
if not response_sent:
    await update.message.reply_text(
        "üö´ <b>Error</b>\n\n"
        "Sorry, I encountered an error processing your message. "
        "Please try again in a moment or use /reset to clear your conversation history.",
        parse_mode=ParseMode.HTML
    )
```

## Bot Lifecycle Management

### 1. Initialization Pattern

Proper bot initialization with dependency setup:

```python
# Good: Proper initialization order
async def initialize(self):
    """Initialize the bot and database."""
    await self.db.initialize_database()
    logger.info("Bot initialized successfully")

async def run(self):
    """Run the bot with proper lifecycle management."""
    await self.initialize()

    application = self.create_application()

    try:
        await application.initialize()
        await application.start()
        await application.updater.start_polling()

        # Keep running until interrupted
        while True:
            await asyncio.sleep(1)
    except KeyboardInterrupt:
        logger.info("Shutting down bot...")
    finally:
        # Proper cleanup
        await application.updater.stop()
        await application.stop()
        await application.shutdown()
```

### 2. Resource Cleanup

Always clean up resources properly:

```python
# Good: Resource cleanup in finally blocks
finally:
    # Stop typing indicator
    await self.stop_typing_indicator(user_id)

    # Cleanup any pending tasks
    for task in self.typing_tasks.values():
        task.cancel()
```

### 3. Configuration Management

Environment-based configuration with validation:

```python
# Good: Configuration validation
def __init__(self):
    self.token = os.getenv("TELEGRAM_BOT_TOKEN")
    if not self.token:
        raise ValueError("TELEGRAM_BOT_TOKEN environment variable is required")

    # Configuration with sensible defaults
    self.rate_limit_messages = int(os.getenv("RATE_LIMIT_MESSAGES_PER_MINUTE", "10"))
    self.rate_limit_window = int(os.getenv("RATE_LIMIT_WINDOW_SECONDS", "60"))
```
