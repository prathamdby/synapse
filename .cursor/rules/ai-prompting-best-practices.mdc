---
alwaysApply: true
---

# AI Prompting Best Practices

## Core Prompting Philosophy

Based on Cursor's prompt design principles and Parahelp's advanced prompting techniques, treat prompting as **prompt design** - similar to web design with dynamic content, clear communication, and responsive adaptation.

### References

- [Cursor Blog: Prompt Design](https://cursor.com/blog/prompt-design)
- [Parahelp Blog: AI Prompt Design](https://parahelp.com/blog/prompt-design)

## System Prompt Architecture

### 1. Ultra-Strict HTML Compliance Protocol

**CRITICAL**: Any HTML parsing error causes complete system failure in Telegram bots.

```html
<!-- ONLY use these 7 allowed tags -->
<b>text</b>
<!-- Bold -->
<i>text</i>
<!-- Italic -->
<u>text</u>
<!-- Underline -->
<s>text</s>
<!-- Strikethrough -->
<code>text</code>
<!-- Inline code -->
<pre>text</pre>
<!-- Code block -->
<a href="url">text</a>
<!-- Links -->
```

**FORBIDDEN** (will crash system):

- Empty tags: `<>` or `< >`
- Custom tags: `<vec>` or `<string>`
- HTML tags: `<h1>`, `<div>`, `<ul>`, `<li>`, `<br>`
- Malformed tags: unclosed or nested incorrectly

### 2. Structured System Prompts

Follow this hierarchical structure (as seen in [cerebras_client.py](mdc:cerebras_client.py)):

```xml
<role>Define the assistant's identity</role>

<critical_system_failure_prevention>
CRITICAL warnings about system failures
</critical_system_failure_prevention>

<core_requirements>
- Primary objectives
- Character limits (4000 chars for Telegram)
- Format requirements
</core_requirements>

<user_context>
Dynamic user information for personalization
</user_context>

<html_compliance_protocol>
<step_1_allowed_tags>Exact allowed tags</step_1_allowed_tags>
<step_2_forbidden_examples>Never generate these</step_2_forbidden_examples>
<step_3_character_rules>Special character encoding</step_3_character_rules>
<step_4_list_format>Bullet point format</step_4_list_format>
<step_5_examples>Correct and incorrect examples</step_5_examples>
</html_compliance_protocol>

<mandatory_verification>
Pre-response verification questions
</mandatory_verification>

<training_examples>
Perfect response examples with pattern analysis
</training_examples>
```

### 3. Dynamic Context Integration

Incorporate comprehensive user context for personalization:

```python
user_context = {
    "user_id": user.id,
    "username": user.username,
    "total_messages": len(conversation_history),
    "is_new_user": len(conversation_history) == 0,
    "language_code": user.language_code,
    "is_premium": getattr(user, "is_premium", None)
}
```

## Advanced Prompting Techniques

### 1. Conditional Logic with XML

Use XML if-blocks for complex decision trees (inspired by Parahelp's approach):

```xml
<if_block condition="user_is_new">
    <step>Provide welcome message with basic instructions</step>
</if_block>
<if_block condition="user_has_conversation_history">
    <step>Reference previous context appropriately</step>
</if_block>
```

### 2. Variable Naming Convention

- `<tool_call_result>` for dynamic tool outputs
- `{{policy_variable}}` for specific policy references
- Avoid assumptions about tool call returns

### 3. Multi-Path Planning

Design prompts that handle multiple potential outcomes:

- Plan for success and failure scenarios
- Include fallback strategies
- Never assume tool call results

### 4. Model-Specific Features

Handle different model capabilities dynamically:

```python
def _model_supports_reasoning(self, model: str) -> bool:
    """Only gpt-oss-120b supports reasoning_effort on Cerebras"""
    return model == "gpt-oss-120b"
```

## Error Prevention Strategies

### 1. HTML Sanitization Pipeline

Implement strict HTML sanitization (see [cerebras_client.py](mdc:cerebras_client.py)):

```python
def _sanitize_html_response(self, response: str) -> str:
    """Remove <think> tags and validate HTML structure"""
    think_end = response.find("</think>")
    if think_end != -1:
        response = response[think_end + len("</think>"):].strip()
    return response.strip()
```

### 2. Character Encoding Rules

- `&` → `&amp;`
- `<` → `&lt;` (except in allowed HTML tags)
- `>` → `&gt;` (except in allowed HTML tags)
- `"` → `&quot;` in attributes

### 3. Response Length Limits

- Telegram: 4000 characters maximum
- Always check response length before sending
- Implement graceful truncation if needed

## Conversation Management

### 1. Context Window Management

```python
# Keep only last 20 exchanges (40 messages) to manage context length
if len(updated_history) > 40:
    updated_history = updated_history[-40:]
```

### 2. Memory-Efficient Design

- Store only essential conversation data
- Implement conversation pruning strategies
- Use database for persistent context

### 3. Personalization Strategies

- Address users by first name when appropriate
- Reference conversation history contextually
- Adapt tone based on interaction patterns
- Consider user experience level (new vs returning)

## Prompt Testing and Evaluation

### 1. Systematic Testing

- Test with various user contexts
- Validate HTML output in Telegram
- Check edge cases and error conditions
- Monitor token usage and response times

### 2. Iterative Improvement

- Log failed responses for analysis
- A/B test different prompt variations
- Monitor user satisfaction metrics
- Continuously refine based on real-world usage

### 3. Model Compatibility

- Test across different Cerebras models
- Handle model-specific features gracefully
- Implement fallback strategies for unsupported features
