---
alwaysApply: true
---

# Code Quality and SOLID Principles

## Core Development Philosophy

Write code like a senior engineer with focus on modularity, maintainability, and production readiness. Every component should be testable, extensible, and follow SOLID principles.

## SOLID Principles Implementation

### 1. Single Responsibility Principle (SRP)

Each class and module has one reason to change:

- **[TelegramBot](mdc:main.py)**: Handles only Telegram bot logic and user interactions
- **[DatabaseManager](mdc:database.py)**: Manages only database operations and data persistence
- **[CerebrasClient](mdc:cerebras_client.py)**: Handles only AI API communication and response formatting
- **[CerebrasChat](mdc:langchain_cerebras.py)**: Manages only conversation flow and LangChain integration

### 2. Open/Closed Principle (OCP)

Design for extension without modification:

```python
# Good: Extensible model support
def _model_supports_reasoning(self, model: str) -> bool:
    """Check if a model supports reasoning features."""
    return model == "gpt-oss-120b"

# Good: Configurable parameters
class CerebrasClient:
    def __init__(self, api_key: str = None):
        self.default_model = "gpt-oss-120b"
        self.default_max_completion_tokens = 4096
        self.default_temperature = 0.7
```

### 3. Liskov Substitution Principle (LSP)

Subclasses must be substitutable for their base classes:

```python
# Good: LangChain LLM implementation
class CerebrasLLM(LLM):
    """LangChain LLM wrapper that properly implements the interface"""

    def _call(self, prompt: str, **kwargs) -> str:
        """Implements required LLM interface"""

    async def _acall(self, prompt: str, **kwargs) -> str:
        """Implements async LLM interface"""
```

### 4. Interface Segregation Principle (ISP)

Clients shouldn't depend on interfaces they don't use:

```python
# Good: Focused interfaces
class DatabaseManager:
    async def get_conversation_history(self, user_id: int) -> List[Dict[str, Any]]
    async def update_conversation_history(self, user_id: int, messages: List[Dict[str, Any]])
    async def check_rate_limit(self, user_id: int, max_messages: int, window_seconds: int) -> bool
```

### 5. Dependency Inversion Principle (DIP)

Depend on abstractions, not concretions:

```python
# Good: Dependency injection
class TelegramBot:
    def __init__(self):
        self.db = DatabaseManager(os.getenv("DATABASE_PATH", "./bot_database.db"))
        self.cerebras_chat = CerebrasChat(api_key=os.getenv("CEREBRAS_API_KEY"))
```

## Async/Await Best Practices

### 1. Consistent Async Patterns

All I/O operations should be async:

```python
# Good: Async database operations
async def get_or_create_user(self, user_id: int, username: str = None) -> Dict[str, Any]:
    async with aiosqlite.connect(self.db_path) as db:
        cursor = await db.execute("SELECT * FROM users WHERE user_id = ?", (user_id,))
        user = await cursor.fetchone()
```

### 2. Thread Pool for Sync APIs

Handle synchronous APIs properly:

```python
# Good: Thread pool for sync Cerebras SDK
async def generate_response(self, messages: List[Dict[str, str]]) -> str:
    loop = asyncio.get_event_loop()
    response = await loop.run_in_executor(
        self.executor,
        self._sync_generate_response,
        messages, model, max_tokens, temperature, top_p, reasoning_effort
    )
    return response
```

### 3. Resource Management

Proper cleanup and resource management:

```python
# Good: Context managers and cleanup
async def initialize_database(self):
    async with aiosqlite.connect(self.db_path) as db:
        await db.execute(CREATE_TABLE_SQL)
        await db.commit()

def __del__(self):
    """Cleanup thread pool executor."""
    if hasattr(self, "executor"):
        self.executor.shutdown(wait=False)
```

## Error Handling Patterns

### 1. Graceful Degradation

Always provide fallback behavior:

```python
# Good: Graceful error handling with user feedback
try:
    response = await self.cerebras_chat.chat_with_history(...)
except asyncio.TimeoutError:
    return "‚è±Ô∏è <b>Response took too long</b>\n\nThe AI is taking longer than usual to respond."
except Exception as e:
    logger.error(f"Error generating response: {e}")
    return "üö´ <b>AI Error</b>\n\nI'm having trouble generating a response right now."
```

### 2. Structured Logging

Use structured logging for debugging:

```python
# Good: Structured logging with context
import structlog
logger = structlog.get_logger()

logger.error("Error handling message", error=str(e), user_id=user_id)
logger.info(f"User {user_id} switched to model {selected_model}")
```

### 3. Input Validation

Validate all inputs and handle edge cases:

```python
# Good: Input validation and sanitization
def _sanitize_html_response(self, response: str) -> str:
    """Minimal sanitization to fix common HTML parsing issues."""
    think_end = response.find("</think>")
    if think_end != -1:
        response = response[think_end + len("</think>"):].strip()
    return response.strip()
```

## Code Organization Principles

### 1. Clear Module Boundaries

Each module should have a clear purpose:

```
synapse/
‚îú‚îÄ‚îÄ main.py                 # Bot orchestration and Telegram integration
‚îú‚îÄ‚îÄ database.py            # Data persistence and user management
‚îú‚îÄ‚îÄ cerebras_client.py     # AI API client with async support
‚îú‚îÄ‚îÄ langchain_cerebras.py  # LangChain integration and chat management
‚îî‚îÄ‚îÄ pyproject.toml         # Project configuration
```

### 2. Configuration Management

Centralize configuration with sensible defaults:

```python
# Good: Environment-based configuration with defaults
class TelegramBot:
    def __init__(self):
        self.rate_limit_messages = int(os.getenv("RATE_LIMIT_MESSAGES_PER_MINUTE", "10"))
        self.rate_limit_window = int(os.getenv("RATE_LIMIT_WINDOW_SECONDS", "60"))
```

### 3. Type Hints and Documentation

Use comprehensive type hints and docstrings:

```python
# Good: Clear type hints and documentation
async def update_conversation_history(
    self, user_id: int, messages: List[Dict[str, Any]]
) -> None:
    """Update conversation history for a user.

    Args:
        user_id: Telegram user ID
        messages: List of conversation messages with role and content
    """
```

## Performance Optimization

### 1. Database Optimization

Efficient database operations:

```python
# Good: Batch operations and connection reuse
async with aiosqlite.connect(self.db_path) as db:
    # Multiple operations in single connection
    await db.execute("INSERT INTO users ...")
    await db.execute("UPDATE conversations ...")
    await db.commit()
```

### 2. Memory Management

Efficient memory usage:

```python
# Good: Conversation history pruning
if len(updated_history) > 40:
    updated_history = updated_history[-40:]  # Keep only last 20 exchanges
```

### 3. Concurrent Operations

Use asyncio for concurrent operations:

```python
# Good: Concurrent typing indicator
async def start_typing_indicator(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
    async def typing_loop():
        try:
            while True:
                await context.bot.send_chat_action(chat_id=update.effective_chat.id, action=ChatAction.TYPING)
                await asyncio.sleep(4)
        except asyncio.CancelledError:
            pass

    self.typing_tasks[user_id] = asyncio.create_task(typing_loop())
```

## Testing and Quality Assurance

### 1. Testable Design

Write code that's easy to test:

```python
# Good: Dependency injection makes testing easier
class TelegramBot:
    def __init__(self, db_manager=None, cerebras_client=None):
        self.db = db_manager or DatabaseManager(...)
        self.cerebras_chat = cerebras_client or CerebrasChat(...)
```

### 2. Error Simulation

Design for error testing:

```python
# Good: Configurable timeouts for testing
self.client = Cerebras(api_key=self.api_key, timeout=30.0)
```

### 3. Monitoring and Observability

Include monitoring hooks:

```python
# Good: Metrics and monitoring
logger.info("Bot initialized successfully")
logger.error("Error handling message", error=str(e), user_id=user_id)
```
